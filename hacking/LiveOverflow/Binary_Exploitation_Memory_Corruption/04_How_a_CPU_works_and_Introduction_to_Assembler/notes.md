<https://www.youtube.com/watch?v=6jSKldt7Eqs>

# What is a register?

Some kind of global variable.
Each CPU architecture gives you a limited amount of them (a few dozens).
They all have the same size (typically 32 or 64 bits).

#
# What is the `IP` register?

A special register on an Intel x86 CPU.
The acronym stands for "Instruction Pointer".

At any given time, `IP` points to the next instruction to execute.

The CPU needs this information to know what to execute.
And as  soon as it has  executed this instruction,  `IP` is updated so  that the
process can go on.

---

It might also be named `PC` (aka "Program Counter"), `EIP`, or `RIP`.
It  depends on  which CPU  you're  working with,  and its  architecture: 16-bit,
32-bit or 64-bit.

## What does "it points to" mean?

`IP` does not hold the next instruction itself.
It holds its address.

## What is a 64-bit CPU?

A CPU capable of transferring 64 bits of data per clock cycle.
64 bits  is the amount of  information it can  process each time it  performs an
operation.   The difference  between a  16-bit,  32-bit, and  64-bit CPU  mainly
matters wrt the amount of RAM which can be addressed by the OS.

#
# What does assembly code look like?

Here is some code written in x86 assembler:
```asm
; store value 5 in register eax
mov eax, 0x5
; BTW, "load" is a synonym for "store".
; Also, notice how the semicolon can be used as a comment leader.

; add value 3 to that register
add eax, 0x3

; store value 8 in an another register
mov ebx, 0x8
;    ^

; subtract the 2nd register from the 1st,
; and store the result in the 1st
sub eax, ebx
```
# What if I need more than a few registers to write my program?

Whatever does not fit in the CPU registers, lives in the RAM.

For example, you could have some value in RAM at an address which is held by the
register `ebx`.  To store that value in register `eax`, you would write:

    mov eax, [ebx]
    ;        ^   ^

These brackets mean that you don't want the value in the CPU register `ebx`; you
want whatever value is held in the RAM at the address given by `ebx`.
Similarly, in Python, if you write:

    myarray[123]

You don't want the  value `123`; you want whatever item is  held by `myarray` at
the  index `123`.   In  the previous  `mov` instruction,  you  can imagine  that
`myarray` is implicitly the RAM:

    mov eax, RAM[ebx]
    ;        ^^^
    ; don't actually write that;
    ; it's just to make the code easier to understand

#
# What is the stack?

An area  at the  end of the  RAM, on  the top  of which you  can perform  only 2
operations:

   - push a value
   - pop a value

## What is the `SP` register?

Another special register; the acronym stands for "Stack Pointer".

It might also be named `ESP`, or `RSP`.

At any given  time, `SP` points to the  value at the top of the  stack.  The CPU
needs this information to know:

   - where to push a new value on top of the stack
   - where to find the value to pop out of the stack

And as soon  as the CPU has pushed/popped  a value, `SP` is updated  so that the
process can go on.

---

For example, suppose you only have 1 value in the stack: `0x123`.
The stack looks like this:

    0x123  top of stack    <--- SP

And `SP` holds the last address in RAM.

Now,  you push  a new  value on  top of  the stack,  `0x456`, by  executing this
instruction:

    push 0x456

The new stack looks like this:

    0x456  top of stack    <--- SP
    0x123  end of stack

And `SP` holds the last *but one* address in RAM.

Now, you push a new value on top of the stack, `0x789`:

    push 0x789

The new stack looks like this:

    0x789  top of stack    <--- SP
    0x456
    0x123  end of stack

And `SP` holds the last but *two* address in RAM.

Now, you pop the value at the top of the stack into the register `eax`:

    pop eax

The new stack looks like this:

    0x456  top of stack    <--- SP
    0x123  end of stack

`SP` holds the last but one address in RAM.
And `eax` holds the value `0x789`.

Etc.

BTW, notice  that the `push`  and `pop`  instructions expect different  types of
operands:

   - `push` needs a value (*what* to push)
   - `pop` needs a register name (*where* to store what will be popped)

## How is the stack useful?

When calling  a function, the  CPU jumps to  a different instruction,  where the
function's code starts.  When the function returns, the CPU must jump back right
after the function call, to execute the next instruction.

IOW, the CPU needs to remember where it was.
Besides, a function might call another function, and the process can repeat itself.
IOW, the CPU needs to remember an ordered list of addresses in the code.
That's exactly what the stack is good for.

---

Here is an example:

    0xcccc  top of stack    <--- SP
    0xbbbb
    0xaaaa  end of stack

Here, you can imagine that the code has  called a function A, which has called a
function B, which has called a function C.

`0xaaaa`, `0xbbbb`,  `0xcccc` are the  addresses of the next  instructions after
the calls to the functions A, B, C.

So, when C,  then B, and finally A  return, the CPU will know where  to find the
next instructions to execute: respectively at `0xcccc`, `0xbbbb`, and `0xaaaa`.

## What do these instructions do?
### `call`

It pushes the address of the next  instruction (aka the "return address") on the
top of the stack.

Then, it stores  the address of the  first instruction of the  function (aka the
"call address") into `IP`, so that the CPU jumps to the function's code.

### `ret`

It pops  the address out of  the top of the  stack, and stores it  into `IP`, so
that the CPU jumps back to right after the function call.

#
# What is a status flag?

Most  operations on  registers like  additions  and subtractions  have the  side
effect of  altering status flags which  are set into the  flag register; another
special register.  Each bit inside this register encodes a flag.

## What is `ZF`?

The zero flag.  It's set when the result of the last computation was 0.

Example:

    mov eax, 0x5
    add eax, 0x3

Here we've added 3 to 5, which gives us 8.
8 is different than zero, so inside the flag register, `ZF` is reset (0).

Next, we execute these instructions:

    mov ebx, 0x8
    sub eax, ebx

Here, we subtract the `ebx` register from the `eax` one.
Both held the same value (8), so the result is 0.
As a result, inside the flag register, `ZF` is set (1).

#
# What is a jump?

An unconditional GOTO implemented via the `jmp` instruction.
The latter stores a new address into `IP`.

Example:

    jmp 0x1234

This stores `0x1234` into `IP`.
As a  result, the  CPU will next  execute whatever instruction  is held  at this
address, forgetting whatever address was originally held by `IP`.

This `jmp` instruction is a bit similar to this `mov`:

    mov ip, 0x1234

# What is a branch?

A conditional  GOTO, predicated on `ZF`,  and implemented via the  `je` or `jne`
instruction.

Example:

    je 0x1234

This jumps  to the address `0x1234`,  but only if the  last arithmetic operation
resulted in zero.

---

The test uses zero, because a simple  way to test the equality between 2 numbers
is to test whether their difference is zero.

So this pseudo-code:

    if 5 == 5

Could be written in assembly like this:

    mov eax, 0x5
    mov ebx, 0x5
    sub eax, ebx

    je 0x1234

The first instructions simply compute the difference between 5 and 5.
Since the difference is zero, `ZF` will be set.
And since  `je` is predicated  on `ZF` being set,  it will be  executed, storing
`0x1234` into `IP`,  which in turn will change the  next instruction executed by
the CPU.

OTOH, in this code, `je` will not jump (i.e. it will leave `IP` unchanged):

    mov eax, 0x6
    mov ebx, 0x5
    sub eax, ebx

    je 0x1234

Because the difference between 6 and 5 is not 0.

---

`je` stands for "Jumps if Equal".
`jne` does the opposite of `je`; its acronym stands for "Jumps if Not Equal".

#
# How does the CPU understand instructions names such as `mov`, `add`, or `push`?

It doesn't.
A symbolic name is for the programmer, when they write their source code.
It's also called a mnemonic.

An assembler program must compile this source code into executable machine code.
In the latter, a mnemonic such as  `mov` is actually encoded as an opcode, which
is just a binary number interpreted by the CPU in a special way.

So, if you  were to read the machine  code of `mov eax, 5`  via a *dis*assembler
program, it would just look like a big binary number:

    that's the mov instruction (for the eax register)
    v------v
    1011100000000101000000000000000000000000
            ^------------------------------^
                  that's the 0x5 value

Actually, since  binary is  too hard  to read,  the disassembler  would probably
print it in its hexadecimal form:

    mov eax
    vv
    B805000000
      ^------^
        0x5

