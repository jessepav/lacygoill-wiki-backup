<https://www.youtube.com/watch?v=qS4VWL5R_OM>

Like in a previous video, our goal is  to crack a program which asks for a valid
license key.  However,  this time, the valid  key can't be read  directly from a
register in GDB.

# crack the `license_2` binary by patching a jump around the key's validity check
## open `license_2` in radare2

    $ radare2 build/license_2

## analyze the code, seek to `main()`, and print the disassembly

    [0x00401090]> aaa
    [0x00401090]> s main
    [0x00401176]> pdf

## in the disassembly, find the instruction printing the "WRONG" message

      │   0x004011f8      817dec940300.  cmp dword [var_14h], 0x394
     ┌──< 0x004011ff      750e           jne 0x40120f
     ││   0x00401201      488d3d120e00.  lea rdi, str.Access_Granted_ ; 0x40201a ; "Access Granted!" ; const char *s
     ││   0x00401208      e853feffff     call sym.imp.puts           ; int puts(const char *s)
    ┌───< 0x0040120d      eb1a           jmp 0x401229
    │││   ; CODE XREF from main @ 0x4011ff(x)
    │└──> 0x0040120f      488d3d140e00.  lea rdi, str.WRONG_         ; 0x40202a ; "WRONG!" ; const char *s

## find where the branch comes from, and note its address

An arrow points to the instruction printing "WRONG"; follow it backward:

    v--------v
    0x004011f8      817dec940300.  cmp dword [var_14h], 0x394
    0x004011ff      750e           jne 0x40120f

Here, `0x004011f8`  is the address  of the instruction which  determines whether
the execution will follow the code path leading to the "WRONG" message.

---

BTW, notice that `cmp` compares some variable to the hexadecimal number `0x394`.
The latter can be converted into a decimal number in several ways.
From the shell, via python:

    $ python -c 'print(0x394)'
    916

Or via `rax2(1)`:

    $ rax2 0x394
    916

Also from radare2 itself, via `!rax2`:

    [0x...] !rax2 0x394

Or via `?`:

    [0x...]> ? 0x394
    int32   916
    ...

Notice that `916` matches our `VALID_SUM` macro in `license_2.c`:

    if (sum == VALID_SUM)

IOW, compiling this `if` statement likely results in the previous `cmp` assembly
instruction (as well as the following `jne`).

## add a breakpoint on it

    [0x00401176]> db 0x004011f8

## restart in debug mode providing some (wrong) key

    [0x00401176]> ood my-key

## continue execution until next breakpoint

    [0x7fb1fc156100]> dc
    Checking License: my-key
    hit breakpoint at: 0x4011ff

You can confirm that the execution has indeed stopped at `0x4011ff` by executing
`dr rip` to print the value held by the `rip` register:

    [0x004011f8]> dr rip
    0x004011f8

## reset the `rip` register so that it points to the instruction granting us the access

The latter can be found in the output of `pdf`:

    0x00401201      488d3d120e00.  lea rdi, str.Access_Granted_ ; 0x40201a ; "Access Granted!" ; const char *s
    ^--------^

To reset `rip`, execute `dr`:

    [0x004011f8]> dr rip=0x00401201
    0x004011f8 ->0x00401201

## continue execution (until the end) to be granted the access

    [0x004011f8]> dc
    Access Granted!

##
# crack the `license_2` binary by writing a keygen
## reverse engineer the algorithm
### print a graph of `main()`

    [0x004011ff]> s main
    [0x00401176]> VV

                                  ┌─────────────────────────────────────────────────────┐
                                  │ [0x401176]                                          │
                                  │   ; DATA XREF from entry0 @ 0x4010b1(r)             │
                                  │ 186: int main (int argc, char **argv, char **envp); │
                                  │ ; arg uint32_t argc @ dh                            │
                                  │ ; arg char **argv @ edx                             │
                                  │ ; var char *s @ rbp-0x8                             │
                                  │ ; var size_t var_ch @ rbp-0xc                       │
                                  │ ; var int64_t var_10h @ rbp-0x10                    │
                                  │ ; var uint32_t var_14h @ rbp-0x14                   │
                                  │ ; var uint32_t var_24h @ rbp-0x24                   │
                                  │ ; var char **var_30h @ rbp-0x30                     │
                                  │ endbr64                                             │
                                  │ push rbp                                            │
                                  │ mov rbp, rsp                                        │
                                  │ sub rsp, 0x30                                       │
                                  │ ; argc                                              │
                                  │ mov dword [var_24h], edi                            │
                                  │ ; argv                                              │
                                  │ mov qword [var_30h], rsi                            │
                                  │ cmp dword [var_24h], 2                              │
                                  │ jne 0x40121d                                        │
                                  └─────────────────────────────────────────────────────┘
                                          f t
                                          │ │
                                          │ └────────────────────────┐
                     ┌────────────────────┘                          │
                     │                                               │
                 ┌────────────────────────────────────────┐      ┌─────────────────────────────────────┐
                 │  0x401193 [od]                         │      │  0x40121d [ok]                      │
                 │ mov dword [var_14h], 0                 │      │ ; const char *s                     │
                 │ mov rax, qword [var_30h]               │      │ ; CODE XREF from main @ 0x40118d(x) │
                 │ mov rax, qword [rax + 8]               │      │ ; 0x402031                          │
                 │ mov qword [s], rax                     │      │ ; "Usage: <key>"                    │
                 │ mov rax, qword [s]                     │      │ lea rdi, str.Usage:__key_           │
                 │ ; const char *s                        │      │ ; int puts(const char *s)           │
                 │ mov rdi, rax                           │      │ call sym.imp.puts;[oh]              │
                 │ ; size_t strlen(const char *s)         │      └─────────────────────────────────────┘
                 │ call sym.imp.strlen;[ob]               │          v
                 │ mov dword [var_ch], eax                │          │
                 │ mov rax, qword [s]                     │          │
                 │ mov rsi, rax                           │          │
                 │ ; const char *format                   │          │
                 │ ; 0x402004                             │          │
                 │ ; "Checking License: %s\n"             │          │
                 │ lea rdi, str.Checking_License:__s_n    │          │
                 │ mov eax, 0                             │          │
                 │ ; int printf(const char *format)       │          │
                 │ call sym.imp.printf;[oc]               │          │
                 │ mov dword [var_10h], 0                 │          │
                 │ jmp 0x4011f0                           │          │
                 └────────────────────────────────────────┘          │
                     v                                               │
                     │                                               │
                     └───┐                                           │
                         │                                           └──────────────┐
     ┌─────────────────────┐                                                        │
     │                   │ │                                                        │
     │             ┌─────────────────────────────────────┐                          │
     │             │  0x4011f0 [of]                      │                          │
     │             │ ; CODE XREF from main @ 0x4011d4(x) │                          │
     │             │ mov eax, dword [var_10h]            │                          │
     │             │ cmp eax, dword [var_ch]             │                          │
     │             │ jl 0x4011d6                         │                          │
     │             └─────────────────────────────────────┘                          │
     │                   t f                                                        │
     │                   │ │                                                        │
     │    ┌──────────────┘ │                                                        │
     │    │                └────────────────────────┐                               │
     │    │                                         │                               │
     │┌─────────────────────────────────────┐   ┌───────────────────────────────┐   │
     ││  0x4011d6 [oe]                      │   │  0x4011f8 [og]                │   │
     ││ ; CODE XREF from main @ 0x4011f6(x) │   │ cmp dword [var_14h], 0x394    │   │
     ││ mov eax, dword [var_10h]            │   │ jne 0x40120f                  │   │
     ││ movsxd rdx, eax                     │   └───────────────────────────────┘   │
     ││ mov rax, qword [s]                  │         t f                           │
     ││ add rax, rdx                        │         │ │                           │
     ││ movzx eax, byte [rax]               │         │ │                           │
     ││ movsx eax, al                       │         │ │                           │
     ││ add dword [var_14h], eax            │         │ │                           │
     ││ add dword [var_10h], 1              │         │ │                           │
     │└─────────────────────────────────────┘         │ │                           │
     │    v                                           │ │                           │
     │    │                                           │ │                           │
     └────┘                                           │ │                           │
                                              ┌───────┘ │                           │
        ┌───────────────────────────────────────────────┘                           │
        │                                     │                                     │
    ┌─────────────────────────────────┐   ┌─────────────────────────────────────┐   │
    │  0x401201 [oi]                  │   │  0x40120f [oj]                      │   │
    │ ; const char *s                 │   │ ; const char *s                     │   │
    │ ; 0x40201a                      │   │ ; CODE XREF from main @ 0x4011ff(x) │   │
    │ ; "Access Granted!"             │   │ ; 0x40202a                          │   │
    │ lea rdi, str.Access_Granted_    │   │ ; "WRONG!"                          │   │
    │ ; int puts(const char *s)       │   │ lea rdi, str.WRONG_                 │   │
    │ call sym.imp.puts;[oh]          │   │ ; int puts(const char *s)           │   │
    │ jmp 0x401229                    │   │ call sym.imp.puts;[oh]              │   │
    └─────────────────────────────────┘   │ jmp 0x401229                        │   │
        v                                 └─────────────────────────────────────┘   │
        │                                     v                                     │
        │                                     │                                     │
        └──────────────────────────┐          │                                     │
                                   │ ┌────────┘                                     │
                                   │ │ ┌────────────────────────────────────────────┘
                                   │ │ │
                             ┌───────────────────────────────────────────────────┐
                             │  0x401229 [ol]                                    │
                             │ ; CODE XREFS from main @ 0x40120d(x), 0x40121b(x) │
                             │ mov eax, 0                                        │
                             │ leave                                             │
                             │ ret                                               │
                             └───────────────────────────────────────────────────┘

### walk back the path from where the access is granted

Here is the path which grants us the access:

                                                ┌────────────────────────────┐
                                                │  0x4011f8 [og]             │
                                                │ cmp dword [var_14h], 0x394 │
                                                │ jne 0x40120f               │
                                                └────────────────────────────┘
                                                      t f
                                                      │ │
                                              ┌───────┘ │
        ┌───────────────────────────────────────────────┘
        │                                     │
    ┌──────────────────────────────┐         ...
    │  0x401201 [oi]               │
    │ ; const char *s              │
    │ ; 0x40201a                   │
    │ ; "Access Granted!"          │
    │ lea rdi, str.Access_Granted_ │
    │ ; int puts(const char *s)    │
    │ call sym.imp.puts;[oh]       │
    │ jmp 0x401229                 │
    └──────────────────────────────┘

The access is granted only if the test performed by `jne` is false.
Which means that the  values used in the previous instruction  must be equal (if
they are different, `jne` will succeed):

    cmp dword [var_14h], 0x394

Which means that whatever value held at the address pointed to by `var_14h` must
be equal to 0x394 (916).

### find out what `var_14h` is

It's first declared in the prologue of `main()`:

    var uint32_t var_14h @ rbp-0x14

It's  allocated  some space  at  the  address  held  by `rbp`  (the  BasePointer
Register), at offset `-0x14`.

Then, after the program checks that the user provided a key, it's set to 0:

    mov dword [var_14h], 0

Finally, it's being added the value held by `eax` in each iteration of a loop:

    add dword [var_14h], eax

BTW, we know that this `add` instruction must be inside a loop, because the only
exit path  of its node (labeled  `[oe]` in the  graph) jumps back to  a previous
node (labeled `[of]`); and the only path jumping to `[oe]` comes from `[of]`.
IOW, `[of]` and `[oe]` are connected via 2 paths forming a loop.

---

TODO: finish this section

About `movsx`, and `movzx`, see this:
<https://en.wikipedia.org/wiki/Sign_extension>

About `byte`, `dword`, `qword`, I *think* those are some kind of size specifiers:
they probably mean resp. 8 bits, 16 bits and 32 bits (dword = double word, qword
= quadruple word?).

##
## using the reverse engineered algorithm, write a keygen
### in python

See `./keygen.py`.

### in C

See `./keygen.c`.
