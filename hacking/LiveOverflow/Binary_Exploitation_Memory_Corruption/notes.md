# 01 Introduction to Linux - Installation and the Terminal

<https://www.youtube.com/watch?v=navuBR4aJSs>

Commands mentioned in the video, and which we should use more often:

    $ df -h
    $ free -h
    $ id
    $ cat file | hexdump -C

##
# 02 Writing a simple Program in C

<https://www.youtube.com/watch?v=JGoUaCmMNpE>

## How to copy-paste text from the output of a previous command on the shell's command-line (without tmux)?

Select the text with the mouse, then press the mouse wheel (middle click).
The  terminal should  automatically paste  the highlighted  text at  the current
cursor location.

##
# 03 Writing a simple Program in Python

<https://www.youtube.com/watch?v=ajy1PHWYeyQ>

##
# 04 How a CPU works and Introduction to Assembler

<https://www.youtube.com/watch?v=6jSKldt7Eqs&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=5>

## Assembly language

See also: <https://sockpuppet.org/issue-79-file-0xb-foxport-hht-hacking.txt.html>
Look for the section titled:

   > --[ assembly programming ]-----------

### What is a register?

Some kind of global variable.
Each CPU architecture gives you a limited amount of them (a few dozens).
They all have the same size (typically 32 or 64 bits).

###
### What is the `IP` register?

A special register on an Intel x86 CPU.
The acronym stands for "Instruction Pointer".

At any given time, `IP` points to the next instruction to execute.

The CPU needs this information to know what to execute.
And as  soon as it has  executed this instruction,  `IP` is updated so  that the
process can go on.

---

It might also be named `PC` (aka "Program Counter"), `EIP`, or `RIP`.
It  depends on  which CPU  you're  working with,  and its  architecture: 16-bit,
32-bit or 64-bit.

#### What does "it points to" mean?

`PC` does not hold the next instruction itself.
It holds its address.

#### What is a 64-bit CPU?

A CPU capable of transferring 64 bits of data per clock cycle.
64 bits  is the amount of  information it can  process each time it  performs an
operation.   The difference  between a  16-bit,  32-bit, and  64-bit CPU  mainly
matters wrt to the amount of RAM which can be addressed by the OS.

###
### What does assembly code look like?

Here is some code written in x86 assembler:

    ; store value 5 in register eax
    mov eax, 0x5
    ; BTW, "load" is synonym for "store".
    ; Also, notice how the semicolon can be used as a comment leader.

    ; add value 3 to that register
    add eax, 0x3

    ; store value 8 in an another register
    mov ebx, 0x8
    ;    ^

    ; subtract the 2nd register from the 1st,
    ; and store the result in the first
    sub eax, ebx

### What if I need more than a few registers to write my program?

Whatever does not fit in the CPU registers, lives in the RAM.

For example, you could have some value in RAM at an address which is held by the
register `ebx`.  To store that value in register `eax`, you would write:

    mov eax, [ebx]
    ;        ^   ^

These brackets mean that you don't want the value in the CPU register `ebx`; you
want whatever value is held in the RAM at the address given by `ebx`.
Similarly, in Python, if you write:

    myarray[123]

You don't want the  value `123`; you want whatever item is  held by `myarray` at
the  index `123`.   In  the previous  `mov` instruction,  you  can imagine  that
`myarray` is implicitly the RAM:

    mov eax, RAM[ebx]
    ;        ^^^
    ; don't actually write that;
    ; it's just to make the code easier to understand

###
### What is the stack?

An area  at the  end of the  RAM, on  the top  of which you  can perform  only 2
operations:

   - push a value
   - pop a value

#### What is the `SP` register?

Another special register; the acronym stands for "Stack Pointer".

It might also be named `ESP`, or `RSP`.

At any given  time, `SP` points to the  value at the top of the  stack.  The CPU
needs this information to know:

   - where to push a new value on top of the stack
   - where to find the value to pop out of the stack

And as soon  as the CPU has pushed/popped  a value, `SP` is updated  so that the
process can go on.

---

For example, suppose you only have 1 value in the stack: `0x123`.
The stack looks like this:

    0x123  top of stack    <--- SP

And `SP` holds the last address in RAM.

Now,  you push  a new  value on  top of  the stack,  `0x456`, by  executing this
instruction:

    push 0x456

The new stack looks like this:

    0x456  top of stack    <--- SP
    0x123  end of stack

And `SP` holds the last *but one* address in RAM.

Now, you push a new value on top of the stack, `0x789`:

    push 0x789

The new stack looks like this:

    0x789  top of stack    <--- SP
    0x456
    0x123  end of stack

And `SP` holds the last but *two* address in RAM.

Now, you pop the value at the top of the stack into the register `eax`:

    pop eax

The new stack looks like this:

    0x456  top of stack    <--- SP
    0x123  end of stack

`SP` holds the last but one address in RAM.
And `eax` holds the value `0x789`.

Etc.

BTW, notice  that the `push`  and `pop`  instructions expect different  types of
operands:

   - `push` needs a value (*what* to push)
   - `pop` needs a register (*where* to store what will be popped)

#### How is the stack useful?

When calling  a function, the  CPU jumps to  a different instruction,  where the
function's body starts.  When the function returns, the CPU must jump back right
after the function call, to execute the next instruction.

IOW, the CPU needs to remember where it was.
Besides, a function might call another function, and the process can repeat itself.
IOW, the CPU needs to remember an ordered list of addresses in the code.
That's exactly what the stack is good for.

---

Here is an example:

    0xcccc  top of stack    <--- SP
    0xbbbb
    0xaaaa  end of stack

Here, you can imagine that the code has  called a function A, which has called a
function B, which has called a function C.

`0xaaaa`, `0xbbbb`, `0xcccc` are the addresses of the next instruction after the
calls to function A, B, C.

So, when C,  then B, and finally A  return, the CPU will know where  to find the
next instructions to execute: respectively at `0xcccc`, `0xbbbb`, and `0xaaaa`.

#### What do these instructions do?
##### `call`

It pushes the address of the next  instruction (aka the "return address") on the
top of the stack.

Then,  it stores  the call  address into  `IP`,  so that  the CPU  jumps to  the
function's code.

##### `ret`

It pops  the address out of  the top of the  stack, and stores it  into `IP`, so
that the CPU jumps back to right after the function call.

###
### What is a status flag?

Most  operations on  registers like  additions  and subtractions  have the  side
effect of  altering status flags which  are set into the  flag register; another
special register.  Each bit inside this register encodes a flag.

#### What is `ZF`?

The zero flag.  It's set when the result of the last computation was 0.

Example:

    mov eax, 0x5
    add eax, 0x3

Here we've added 3 to 5, which gives us 8.
8 is different than zero, so inside the flag register, `ZF` is reset (0).

Next, we execute these instructions:

    mov ebx, 0x8
    sub eax, ebx

Here, we subtract the `ebx` register from the `eax` one.
Both held the same value (8), so the result is 0.
As a result, inside the flag register, `ZF` is set (1).

###
### What is a jump?

An unconditional GOTO implemented via the `jmp` instruction.
The latter stores a new address into `IP`.

Example:

    jmp 0x1234

This stores `0x1234` into `IP`.
As a  result, the  CPU will next  execute whatever instruction  is held  at this
address, forgetting whatever address was originally held by `IP`.

This `jmp` instruction is a bit similar to this `mov`:

    mov ip, 0x1234

### What is a branch?

A conditional  GOTO, predicated on `ZF`,  and implemented via the  `je` or `jne`
instruction.

Example:

    je 0x1234

This jumps  to the `0x1234` address,  but only if the  last arithmetic operation
resulted in zero.

---

The test uses zero, because a simple  way to test the equality between 2 numbers
is to test whether their difference is zero.

So this pseudo-code:

    if 5 == 5

Could be written in assembly like this:

    mov eax, 0x5
    mov ebx, 0x5
    sub eax, ebx

    je 0x1234

The first instructions simply compute the difference between 5 and 5.
Since the difference is zero, `ZF` will be set.
And since `je` is predicated on `ZF` being set, `0x1234` will be stored
in `IP`, changing the next instruction executed by the CPU.

OTOH, in this code, `je` will not jump (i.e. it will leave `IP` unchanged):

    mov eax, 0x6
    mov ebx, 0x5
    sub eax, ebx

    je 0x1234

Because the difference between 6 and 5 is not 0.

---

`je` stands for "Jumps if Equal".
`jne` does the opposite of `je`; its acronym stands for "Jumps if Not Equal".

##
## How does the CPU understand instructions names such as `mov`, `add`, or `push`?

It doesn't.
A symbolic name is for the programmer, when they write their source code.
It's also called a mnemonic.

An assembler program must compile this source code into executable machine code.
In the latter, a mnemonic such as  `mov` is actually encoded as an opcode, which
is just a binary number interpreted by the CPU in a special way.

So, if you  were to read the machine  code of `mov eax, 5`  via a *dis*assembler
program, it would just look like a big binary number:

    that's the mov instruction (for the eax register)
    v------v
    1011100000000101000000000000000000000000
            ^------------------------------^
                  that's the 0x5 value

Actually, since  binary is  too hard  to read,  the disassembler  would probably
print it in its hexadecimal form:

    mov eax
    vv
    B805000000
      ^------^
        0x5

##
# 05 Reversing and Cracking first simple Program

The goal of  this exercise is to crack  a simple program which asks  for a valid
license key.  Cracking means that we don't  have access to the source code; only
the machine code.  Here,  we do have the source code, but  we'll pretend that we
don't.

## compile the source code into machine code

    $ cd code/05_Reversing_and_Cracking_first_simple_Program/
    $ mkdir build/
    $ gcc license_1.c -o build/license_1

## turn the machine code back into assembly code, because it's more readable

This can be achieved by executing `disassemble main` from gdb:

    $ gdb --ex='set disassembly-flavor intel' \
          --ex='disassemble main' \
          --batch build/license_1 \
          | sed '1d; $d; s/^\s\+\|\s\+$//g' \
          >/tmp/asm.asm
    #              ^--^
    #              to get syntax highlighting in Vim

    $ vim /tmp/asm.asm

Here is the output:
```asm
0x0000000000001189 <+0>:        endbr64
0x000000000000118d <+4>:        push   rbp
0x000000000000118e <+5>:        mov    rbp,rsp
0x0000000000001191 <+8>:        sub    rsp,0x10
0x0000000000001195 <+12>:       mov    DWORD PTR [rbp-0x4],edi
0x0000000000001198 <+15>:       mov    QWORD PTR [rbp-0x10],rsi
0x000000000000119c <+19>:       cmp    DWORD PTR [rbp-0x4],0x2
0x00000000000011a0 <+23>:       jne    0x11fb <main+114>
0x00000000000011a2 <+25>:       mov    rax,QWORD PTR [rbp-0x10]
0x00000000000011a6 <+29>:       add    rax,0x8
0x00000000000011aa <+33>:       mov    rax,QWORD PTR [rax]
0x00000000000011ad <+36>:       mov    rsi,rax
0x00000000000011b0 <+39>:       lea    rdi,[rip+0xe4d]        # 0x2004
0x00000000000011b7 <+46>:       mov    eax,0x0
0x00000000000011bc <+51>:       call   0x1080 <printf@plt>
0x00000000000011c1 <+56>:       mov    rax,QWORD PTR [rbp-0x10]
0x00000000000011c5 <+60>:       add    rax,0x8
0x00000000000011c9 <+64>:       mov    rax,QWORD PTR [rax]
0x00000000000011cc <+67>:       lea    rsi,[rip+0xe47]        # 0x201a
0x00000000000011d3 <+74>:       mov    rdi,rax
0x00000000000011d6 <+77>:       call   0x1090 <strcmp@plt>
0x00000000000011db <+82>:       test   eax,eax
0x00000000000011dd <+84>:       jne    0x11ed <main+100>
0x00000000000011df <+86>:       lea    rdi,[rip+0xe44]        # 0x202a
0x00000000000011e6 <+93>:       call   0x1070 <puts@plt>
0x00000000000011eb <+98>:       jmp    0x1207 <main+126>
0x00000000000011ed <+100>:      lea    rdi,[rip+0xe46]        # 0x203a
0x00000000000011f4 <+107>:      call   0x1070 <puts@plt>
0x00000000000011f9 <+112>:      jmp    0x1207 <main+126>
0x00000000000011fb <+114>:      lea    rdi,[rip+0xe3f]        # 0x2041
0x0000000000001202 <+121>:      call   0x1070 <puts@plt>
0x0000000000001207 <+126>:      mov    eax,0x0
0x000000000000120c <+131>:      leave
0x000000000000120d <+132>:      ret
```
---

Tip:  `set disassembly-flavor intel`  changes  the  syntax   of  the  printed
instructions from  the default AT&T to  intel.  To avoid having  to execute this
command every time you start gdb, write it in a gdb initialization script:

    $ echo 'set disassembly-flavor intel' >>~/.config/gdb/gdbearlyinit

For more info, see `man gdbinit`, as well as:
<https://sourceware.org/gdb/current/onlinedocs/gdb/Machine-Code.html#index-Intel-disassembly-flavor>

Also, add  `set startup-quietly on`  to suppress the introductory  and copyright
messages:

    $ echo 'set disassembly-flavor intel' >>~/.config/gdb/gdbearlyinit

##
## note the most important instructions

Here, there  are only a few  instructions which determine the  program's control
flow:  2 `jne`s, 2 `jmp`s, 1 `cmp`, 1 `test`, and 1 `ret`.  There are also a few
`call`s.  Those are  the only instructions which we need  to understand what the
code is doing at a high level:

    0x000000000000119c <+19>:       cmp    DWORD PTR [rbp-0x4],0x2
    0x00000000000011a0 <+23>:       jne    0x11fb <main+114>
    0x00000000000011bc <+51>:       call   0x1080 <printf@plt>
    0x00000000000011d6 <+77>:       call   0x1090 <strcmp@plt>
    0x00000000000011db <+82>:       test   eax,eax
    0x00000000000011dd <+84>:       jne    0x11ed <main+100>
    0x00000000000011e6 <+93>:       call   0x1070 <puts@plt>
    0x00000000000011eb <+98>:       jmp    0x1207 <main+126>
    0x00000000000011f4 <+107>:      call   0x1070 <puts@plt>
    0x00000000000011f9 <+112>:      jmp    0x1207 <main+126>
    0x0000000000001202 <+121>:      call   0x1070 <puts@plt>
    0x000000000000120d <+132>:      ret

There is  still some  noise in there.   We only  need the last  3 digits  of the
addresses in the first column (which we can use as a label to quickly identify a
location) and the name of the instruction  in the 3rd column.  We also need some
parts of the operands:

   - for `jne`, the address of the jump
   - for `cmp`, the number value which is compared
   - for `test`, the register name which is tested
   - for `call`, the name of the called function

Which gives:

    19c  cmp   0x2
    1a0  jne   0x11fb
    1bc  call  printf
    1d6  call  strcmp
    1db  test  eax
    1dd  jne   0x11ed
    1e6  call  puts
    1eb  jmp   0x1207
    1f4  call  puts
    1f9  jmp   0x1207
    202  call  puts
    20d  ret

### What does this `test   eax,eax` instruction do?

[`test`][1] performs a bitwise AND on its 2 operands: `operand1 & operand2`.
But the purpose of  `test` is not the result of this  computation; the latter is
discarded.  The purpose is to set some status flags; one of them being `ZF`.

So `test eax,eax` computes `eax & eax`.
For `ZF` to be set, the result must be 0.
For the result to be 0, all the bits  in `eax` must be 0; i.e. `eax` itself must
hold the value 0.

So these instructions:

    test   eax,eax
    jne    0x11ed

check whether  `eax` is  0.  And  if it's  not, the  execution jumps  to another
address.

Besides, since these lines follow a call to `strcmp()`, we can assume that `eax`
holds the return value of the latter.  IOW, these 3 lines:

    call  strcmp
    test  eax,eax
    jne   0x11ed

test whether 2 strings are equal, and the execution jumps somewhere else if they
are not.

##
## draw the control-flow diagram around these instructions

    +-------------------+
    | 19c  cmp   0x2    |
    | 1a0  jne   0x11fb |
    +-------------------+
              |          \   XXX (we don't know what it is yet)
              |           \  is not equal to 2
    XXX       |            v
    is equal  |            +-----------------+
    to 2      |            | 1fb             |
              |            | 202  call  puts | print some message (let's call it MSG1)
              |            | 20d  ret        | exit (return from main())
              |            +-----------------+
              v
    +-------------------+
    | 1a2               |
    | 1bc  call  printf | print some message (MSG2)
    | 1d6  call  strcmp | compare 2 strings
    | 1db  test  eax    | if the strings are different
    | 1dd  jne   0x11ed | jump to this bottom-right box
    +-------------------+
                     |   \
                     |    \ the strings are different
                     |     \
                     |      v
    the strings are  |      +-------------------+
    the same         |      | 1ed               |
                     |      | 1f4  call  puts   | print some message (MSG3)
                     |      | 1f9  jmp   0x1207 | jump near the exit
                     |      | 20d  ret          | exit
                     |      + ------------------+
                     v
    +-------------------+
    | 1df               |
    | 1e6  call  puts   | print some message (MSG4)
    | 1eb  jmp   0x1207 | jump near the exit
    | 20d  ret          | exit
    +-------------------+

Notice that at the top of most boxes, we've put some address without a following
instruction name.  These will be helpful  later to follow the execution during a
debugging session; that is,  when the code branches, they will  help us find out
which path is taken by the execution.

##
## start a debugging session without providing a key

    $ gdb build/license_1

    # add breakpoint
    (gdb) break *main

    # run the program
    (gdb) run

    # step over the next instruction
    (gdb) ni
    # if you wanted to step inside a function call,
    # you would execute `si` instead of `ni`

Now,  keep pressing  `Enter` to  repeat  the last  `ni` command,  until you  see
something interesting.  After a few `Enter`,  you should notice that the program
prints a  usage message.  The  address of  the instruction responsible  for this
message is given right before, and  ends with `202`.  It matches the instruction
which we noted in our previous diagram:

    202  call  puts

And right before, we also noted that the program compares `XXX` to 2.
After printing the usage message, `main()` exits.
Something went wrong.  What?  The simplest answer is that the program expected a
key, but we didn't provide one.

This means  that the purpose of  the `XXX ==  2` comparison is to  check whether
we've given a key.  If you wonder why the code compares `XXX` to 2 instead of 1,
remember that the first argument received by  `main()` is always the name of the
program itself, exactly as  you invoked it.  So, if you  provide a key, `main()`
receives 2 arguments: the name of  the program (e.g. `build/license_1`), and the
key (e.g. `my-key`).

From what we've observed during this debugging session, we can infer that:

   - `XXX` is the number of arguments received by `main()`
   - `MSG1` is `main()`'s usage message

There are  still a  few missing  info in  the diagram;  namely what  are `MSG2`,
`MSG3` and `MSG4`?  We'll need to start a new debugging session to find out.

### What was the purpose of the asterisk in `break *main`?

It  asks  gdb to  stop  the  execution right  before  the  first instruction  of
`main()`.  Without, it would stop right after its [prologue][2].

   > The difference is that b *main breaks  on the first instruction of main, while b
   > main breaks on the first instruction after the function prologue.

Source: <https://stackoverflow.com/questions/40960758/break-main-vs-break-main-in-gdb>

##
## start a new debugging session; this time *do* provide a key

You don't need to quit gdb and start a new instance.
Stay inside gdb, and run `run my-key`:

    (gdb) run my-key
    # press "y" at this prompt:
    #     The program being debugged has been started already.
    #     Start it from the beginning? (y or n) y
    (gdb) ni

After pressing `Enter` a few times to repeat `ni`, you should notice notice that
the  execution jumps  from  `1a0` to  `1a2`.   This means  that  this time,  the
execution has followed the left path in the diagram, instead of the right one.

A few more `ni`, and you should get this message:

    Checking License: my-key

It's caused by the instruction at the address `1bc`.
We can infer that `MSG2` is this "Checking License" message.

A few more `ni`, and you should get this message:

    WRONG!

It's caused by the instruction at the address `1f4`.
We can infer that `MSG3` is this "WRONG!" message.

This happens right after  the jump from `1dd` to `1ed`,  which is performed when
the comparison between 2 strings fails.

We can  infer that the  compared strings  are the key  which we provided  on the
gdb's command-line, and the valid key hard-coded inside the compiled program.

## finally, crack the key

The path leading  to the "WRONG!" message (`MSG3` in  our diagram) is determined
by the result of the previous test which is:

    1db  test  eax

Let's put a breakpoint right before:

    # only works as expected if executed after run (not before)
    (gdb) break *0x00005555555551db

To  type the  address of  the  `test` instruction  more easily,  you can  re-run
`disassemble main`, then look for it inside:

Then select the address with the mouse:

    0x00005555555551db <+82>:    test   eax,eax
    ^----------------^

and press the mouse wheel.

Next, re-start the program:

    (gdb) run my-key

The execution  might stop  at the  first breakpoint,  which is  at the  start of
`main()`.  We don't care about what happens when `main()` starts, so skip to the
next interesting breakpoint:

    (gdb) continue

The execution should stop at the breakpoint right before the `test`.
At that moment, inspect the values held by the registers:

    (gdb) info registers

In the output, there is no line for the `eax` register.
That's because `eax` actually refers to the first 32 bits of the `rax` register.
So, look for a line starting with `rax`.  You should find something like this:

    rax            0x2c                44

We can  see that its  value is  `2c` in hexadecimal,  which converts to  `44` in
decimal.  It's  not equal  to 0,  which is why  the following  `jne` instruction
causes the  execution to follow  the path on the  right to the  "WRONG!" message
(`MSG3` in our diagram).

We don't want  that.  Let's try to  make the execution follow  another path; the
one on the left (that's the only other possible path in our diagram).

To achieve this, we need to reverse the test result.
As of right now, the test is going to fail.
To make it pass, we need `rax` to hold the value 0:

    (gdb) set $rax = 0

Let's make sure we've reset `rax`:

    (gdb) info registers

If it worked, you should find this line:

    rax            0x0                 0

Finally, run `ni` a few more times.
You should notice  that this time, the  execution follows the path  on the left,
and you  should get the message  "Access Granted!".  Since you  were granted the
access without providing the valid key, you've cracked the program.

##
## Useful links

To practice more, and crack other programs, visit: <https://crackmes.one/>
To install tools specialized to disassemble binaries, try one of these:

   - <https://github.com/NationalSecurityAgency/ghidra>
   - <https://github.com/radareorg/radare2>

Among other things, they can help you draw a diagram like the one before.

##
# 09 Syscalls, Kernel vs. User Mode and Linux Kernel Source Code

<https://www.youtube.com/watch?v=fLS99zJDHOc>

What are syscalls?
What is user-mode?
What is kernel-mode?

syscalls are an interface between kernel-mode and user-mode.
From `man syscalls(2)`:

   > The system call is the fundamental interface between an application and
   > the Linux kernel.

   > System calls are generally not invoked directly, but rather via wrapper
   > functions in glibc [...]

   > Often the glibc wrapper function is quite thin, doing little work other
   > than copying arguments to the right registers before invoking the system
   > call, [...]


##
# Reference

[1]: https://en.wikipedia.org/wiki/TEST_(x86_instruction)
[2]: https://en.wikipedia.org/wiki/Function_prologue_and_epilogue
