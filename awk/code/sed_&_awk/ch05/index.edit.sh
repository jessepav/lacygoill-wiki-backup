#!/bin/bash
# index.edit -- compile list of index entries for editing.

# Purpose:{{{
# When the script is run on a file, it creates a listing similar to this:
#
#     $ index.edit.sh ch05
#
#     /^\.XX /s/"append command(a)"/"append command(a)"/
#     /^\.XX /s/"change command(c)"/"change command(c)"/
#     /^\.XX /s/"delete command(d)"/"delete command(d)"/
#     /^\.XX /s/"insert command(i)"/"insert command(i)"/
#     /^\.XX /s/"list command(l)"/"list command(l)"/
#
# This output could be captured in a file.
# Then you can  delete the entries that  don't need to change, and  you can make
# changes by editing the replacement string.
# At that  point, you can  use this file  as a sed  script to correct  the index
# entries in all document files.
#}}}

# delimiter of the second `s` command (the one generated by the replacement field of the first `s`)
A="$(tr 'x' '\001' <<<'x')"
# Why is `sort -u` important?{{{
#
# To sort and remove duplicate lines.
# If we keep duplicate lines, we may perform two substitutions on the same line,
# which may have unexpected results.
#}}}
grep '^\.XX' "$@" \
  | sort -u \
  | sed "s!^\.XX \(.*\)\$!/^\\.XX /s${A}\1${A}\1${A}!"
  #                         ├┘{{{
  #                         └ the first backslash protects the dot from the first `s` command;
  #
  #                           the second backslash protects the dot from sed
  #                           when it will run the the second `s` command
  #}}}

# Note that we need a ‘C-a’ as a delimiter for the second `s`.{{{
#
# Whatever delimiter we choose, it may end up being present in the replacement of `\1`.
# But it's unlikely that it contains ‘C-a’.
#}}}
# But we don't need a ‘C-b’ as a delimiter for the first `s`.{{{
#
# We use `!` and we *know* it will work fine.
#
# Indeed, we know exactly all the characters present in the first `s`.
# You may  wonder about `\1`, but  the replacement of the  latter doesn't matter
# when the first `s` is parsed.
# What matters is that no characters in the replacement field conflicts with the
# delimiter `!`; which is the case here; neither `\` nor `1` conflicts with `!`.
#}}}
# Note that the dollar sign in `$!` is escaped.{{{
#
# Otherwise, `$!` would be replaced by the pid of the current job.
# We need the backslash because we're in a double-quoted string.
# We need double quotes to let bash interpolate `$A`.
#}}}
# Note that the first `s` command is going to be run now by the script, but not the second one.{{{
#
# The second one is just written in the replacement field of the first `s` command.
# It will be run  later, after we redirect the output of this  script in a file,
# edit and review the latter, then run it as a sed script.
#}}}
